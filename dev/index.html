<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · CodeSearch.jl</title><meta name="title" content="Home · CodeSearch.jl"/><meta property="og:title" content="Home · CodeSearch.jl"/><meta property="twitter:title" content="Home · CodeSearch.jl"/><meta name="description" content="Documentation for CodeSearch.jl."/><meta property="og:description" content="Documentation for CodeSearch.jl."/><meta property="twitter:description" content="Documentation for CodeSearch.jl."/><meta property="og:url" content="https://LilithHafner.github.io/CodeSearch.jl/"/><meta property="twitter:url" content="https://LilithHafner.github.io/CodeSearch.jl/"/><link rel="canonical" href="https://LilithHafner.github.io/CodeSearch.jl/"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>CodeSearch.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#How-to-use-this-package"><span>How to use this package</span></a></li><li><a class="tocitem" href="#Reference"><span>Reference</span></a></li><li><a class="tocitem" href="#Performance"><span>Performance</span></a></li><li><a class="tocitem" href="#Credits"><span>Credits</span></a></li></ul></li><li><a class="tocitem" href="internals/">Internals</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/LilithHafner/CodeSearch.jl/blob/main/docs/src/index.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="CodeSearch.jl"><a class="docs-heading-anchor" href="#CodeSearch.jl">CodeSearch.jl</a><a id="CodeSearch.jl-1"></a><a class="docs-heading-anchor-permalink" href="#CodeSearch.jl" title="Permalink"></a></h1><p><a href="https://github.com/LilithHafner/CodeSearch.jl">CodeSearch.jl</a> is a package for semantically searching Julia code. Unlike plain string search and regex search, CodeSearch performs search operations <em>after</em> parsing. Thus the search patterns <code>j&quot;a + b&quot;</code> and <code>j&quot;a+b&quot;</code> are equivalent, and both match the code <code>a +b</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; using CodeSearch

julia&gt; j&quot;a + b&quot; == j&quot;a+b&quot;
true

julia&gt; findfirst(j&quot;a+b&quot;, &quot;sqrt(a +b)/(a+ b)&quot;)
6:9</code></pre><p>The other key feature in this package is wildcard matching. You can use the character <code>*</code> to match any expression. For example, the pattern <code>j&quot;a + *&quot;</code> matches both <code>a + b</code> and <code>a + (b + c)</code> .</p><pre><code class="language-julia-repl hljs">julia&gt; Expr.(eachmatch(j&quot;a + *&quot;, &quot;a + (a + b), a + sqrt(2)&quot;))
3-element Vector{Expr}:
 :(a + (a + b))
 :(a + b)
 :(a + sqrt(2))</code></pre><p>Here we can see that <code>j&quot;a + *&quot;</code> matches multiple places, even some that nest within eachother!</p><p>Finally, it is possible to extract the &quot;captured values&quot; that match the wildcards.</p><pre><code class="language-julia-repl hljs">julia&gt; m = match(j&quot;a + *&quot;, &quot;a + (a + b), a + sqrt(2)&quot;)
CodeSearch.Match((call-i a + (call-i a + b)), captures=[(call-i a + b)])

julia&gt; m.captures
1-element Vector{JuliaSyntax.SyntaxNode}:
 (call-i a + b)

julia&gt; Expr(only(m.captures))
:(a + b)</code></pre><h2 id="How-to-use-this-package"><a class="docs-heading-anchor" href="#How-to-use-this-package">How to use this package</a><a id="How-to-use-this-package-1"></a><a class="docs-heading-anchor-permalink" href="#How-to-use-this-package" title="Permalink"></a></h2><ol><li>Create <a href="#CodeSearch.Pattern"><code>Pattern</code></a>s with the <a href="#CodeSearch.@j_str"><code>@j_str</code></a> macro or the  <a href="#CodeSearch.pattern"><code>CodeSearch.pattern</code></a> function.</li><li>Search an <code>AbstractString</code> or a <code>JuliaSyntax.SyntaxNode</code> for whether and where that  pattern occurs with generic functions like <code>occursin</code>, <code>findfirst</code>, <code>findlast</code>, or  <code>findall</code> <em>OR</em> extract the actual <a href="#CodeSearch.Match"><code>Match</code></a>es with generic functions like <code>eachmatch</code> and  <code>match</code>.</li><li>If you extracted an actual match, access relevant information using the public  <code>syntax_node</code> and <code>captures</code> fields, convert to a <code>SyntaxNode</code>, <code>Expr</code>, or  <code>AbstractString</code> via constructors, index into the captures directly with <code>getindex</code>, or  extract the indices in the original string that match the capture with  <a href="#CodeSearch.indices"><code>indices</code></a>.</li></ol><h2 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h2><ul><li><a href="#CodeSearch.@j_str"><code>@j_str</code></a></li><li><a href="#CodeSearch.pattern"><code>CodeSearch.pattern</code></a></li><li><a href="#CodeSearch.Pattern"><code>CodeSearch.Pattern</code></a></li><li><a href="#CodeSearch.Match"><code>CodeSearch.Match</code></a></li><li><a href="#CodeSearch.indices"><code>indices</code></a></li><li><a href="#Generic-functions">Generic functions</a></li></ul><p>The following are manually selected docstrings</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodeSearch.@j_str" href="#CodeSearch.@j_str"><code>CodeSearch.@j_str</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">j&quot;str&quot; -&gt; Pattern</code></pre><p>Construct a <code>Pattern</code>, such as <code>j&quot;a + (b + *)&quot;</code> that matches Julia code.</p><p>The <code>*</code> character is a wildcard that matches any expression, and matching is performed insensitive of whitespace and comments. Only the characters <code>&quot;</code> and <code>*</code> must be escaped, and interpolation is not supported.</p><p>See <a href="#CodeSearch.pattern"><code>pattern</code></a> for the function version of this macro if you need interpolation.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; j&quot;a + (b + *)&quot;
j&quot;a + (b + *)&quot;

julia&gt; match(j&quot;(b + *)&quot;, &quot;(b + 6)&quot;)
CodeSearch.Match((call-i b + 6), captures=[6])

julia&gt; findall(j&quot;* + *&quot;, &quot;(a+b)+(d+e)&quot;)
3-element Vector{UnitRange{Int64}}:
 1:11
 2:4
 8:10

julia&gt; match(j&quot;(* + *) \* *&quot;, &quot;(a-b)*(d+e)&quot;) # no match -&gt; returns nothing

julia&gt; occursin(j&quot;(* + *) \* *&quot;, &quot;(a-b)*(d+e)&quot;)
false

julia&gt; eachmatch(j&quot;*(\&quot;hello world\&quot;)&quot;, &quot;print(\&quot;hello world\&quot;), display(\&quot;hello world\&quot;)&quot;)
2-element Vector{CodeSearch.Match}:
 Match((call print (string &quot;hello world&quot;)), captures=[print])
 Match((call display (string &quot;hello world&quot;)), captures=[display])

julia&gt; count(j&quot;*(*)&quot;, &quot;a(b(c))&quot;)
2

julia&gt; match(j&quot;(* + *) \* *&quot;, &quot;(a+b)*(d+e)&quot;)
CodeSearch.Match((call-i (call-i a + b) * (call-i d + e)), captures=[a, b, (call-i d + e)])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LilithHafner/CodeSearch.jl/blob/a017b4ecb0a90d558f40a30801e6646846b00bad/src/CodeSearch.jl#L84-L126">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodeSearch.pattern" href="#CodeSearch.pattern"><code>CodeSearch.pattern</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pattern(str::AbstractString) -&gt; Pattern</code></pre><p>Function version of the <code>j&quot;str&quot;</code> macro. See <a href="#CodeSearch.@j_str"><code>@j_str</code></a> for documentation.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using CodeSearch: pattern

julia&gt; pattern(&quot;a + (b + *)&quot;)
j&quot;a + (b + *)&quot;

julia&gt; match(pattern(&quot;(b + *)&quot;), &quot;(b + 6)&quot;)
CodeSearch.Match((call-i b + 6), captures=[6])

julia&gt; findall(pattern(&quot;* + *&quot;), &quot;(a+b)+(d+e)&quot;)
3-element Vector{UnitRange{Int64}}:
 1:11
 2:4
 8:10

julia&gt; match(pattern(&quot;(* + *) \\* *&quot;), &quot;(a-b)*(d+e)&quot;) # no match -&gt; returns nothing

julia&gt; occursin(pattern(&quot;(* + *) \\* *&quot;), &quot;(a-b)*(d+e)&quot;)
false

julia&gt; eachmatch(pattern(&quot;*(\&quot;hello world\&quot;)&quot;), &quot;print(\&quot;hello world\&quot;), display(\&quot;hello world\&quot;)&quot;)
2-element Vector{CodeSearch.Match}:
 Match((call print (string &quot;hello world&quot;)), captures=[print])
 Match((call display (string &quot;hello world&quot;)), captures=[display])

julia&gt; count(pattern(&quot;*(*)&quot;), &quot;a(b(c))&quot;)
2

julia&gt; match(pattern(&quot;(* + *) \\* *&quot;), &quot;(a+b)*(d+e)&quot;)
CodeSearch.Match((call-i (call-i a + b) * (call-i d + e)), captures=[a, b, (call-i d + e)])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LilithHafner/CodeSearch.jl/blob/a017b4ecb0a90d558f40a30801e6646846b00bad/src/CodeSearch.jl#L131-L168">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodeSearch.Pattern" href="#CodeSearch.Pattern"><code>CodeSearch.Pattern</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Pattern &lt;: AbstractPattern</code></pre><p>A struct that represents a Julia expression with wildcards. When matching <code>Pattern</code>s, it is possilbe for multiple matches to nest within one another.</p><p>The fields and constructor of this struct are not part of the public API. See <a href="#CodeSearch.@j_str"><code>@j_str</code></a> and <a href="#CodeSearch.pattern"><code>pattern</code></a> for the public API for creating <code>Pattern</code>s.</p><p>Methods accepting <code>Pattern</code> objects are defined for <code>eachmatch</code>, <code>match</code>, <code>findall</code>, <code>findfirst</code>, <code>findlast</code>, <code>occursin</code>, and <code>count</code>.</p><p><strong>Extended Help</strong></p><p>The following are implmenetation details:</p><p>The expression is stored as an ordinary <code>SyntaxNode</code> in the internal <code>syntax_node</code> field. Wildcards in that expression are represented by the symbol stored in the internal <code>wildcard_symbol</code> field. For example, the expression <code>a + (b + *)</code> might be stored as <code>Pattern((call-i a + (call-i b + wildcard)), :wildcard)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LilithHafner/CodeSearch.jl/blob/a017b4ecb0a90d558f40a30801e6646846b00bad/src/CodeSearch.jl#L56-L77">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodeSearch.Match" href="#CodeSearch.Match"><code>CodeSearch.Match</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Match &lt;: AbstractMatch
    syntax_node::JuliaSyntax.SyntaxNode
    captures::Vector{JuliaSyntax.SyntaxNode}
end</code></pre><p>Represents a single match to a <a href="#CodeSearch.Pattern"><code>Pattern</code></a>, typically created from the <code>eachmatch</code> or <code>match</code> function.</p><p>The <code>syntax_node</code> field stores the <code>SyntaxNode</code> that matched the <a href="#CodeSearch.Pattern"><code>Pattern</code></a> and the <code>captures</code> field stores the <code>SyntaxNode</code>s that fill match each wildcard in the <a href="#CodeSearch.Pattern"><code>Pattern</code></a>, indexed in the order they appear.</p><p>Methods that accept <code>Match</code> objects are defined for <code>Expr</code>, <code>SyntaxNode</code>, <code>AbstractString</code>, <a href="#CodeSearch.indices"><code>indices</code></a>, and <code>getindex</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; m = match(j&quot;√*&quot;, &quot;2 + √ x&quot;)
CodeSearch.Match((call-pre √ x), captures=[x])

julia&gt; m.captures
1-element Vector{JuliaSyntax.SyntaxNode}:
 x

julia&gt; m[1]
line:col│ tree        │ file_name
   1:7  │x

julia&gt; Expr(m)
:(√x)

julia&gt; AbstractString(m)
&quot; √ x&quot;

julia&gt; CodeSearch.indices(m)
4:9</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LilithHafner/CodeSearch.jl/blob/a017b4ecb0a90d558f40a30801e6646846b00bad/src/CodeSearch.jl#L12-L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodeSearch.indices" href="#CodeSearch.indices"><code>CodeSearch.indices</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">indices(m)</code></pre><p>Return the indices into a source datastructure that a view is derived from.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; m = match(j&quot;x/*&quot;, &quot;4 + x/2&quot;)
CodeSearch.Match((call-i x / 2), captures=[2])

julia&gt; indices(m)
4:7

julia&gt; c = m[1]
line:col│ tree        │ file_name
   1:7  │2


julia&gt; indices(c)
7:7</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LilithHafner/CodeSearch.jl/blob/a017b4ecb0a90d558f40a30801e6646846b00bad/src/CodeSearch.jl#L291-L312">source</a></section></article><h3 id="Generic-functions"><a class="docs-heading-anchor" href="#Generic-functions">Generic functions</a><a id="Generic-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Generic-functions" title="Permalink"></a></h3><p>Many functions that accept <code>Regex</code>s also accept <code>CodeSearch.Pattern</code>s and behave according to their generic docstrings. Here are some of those supported functions:</p><ul><li><code>findfirst</code></li><li><code>findlast</code></li><li><code>findall</code></li><li><code>eachmatch</code></li><li><code>match</code></li><li><code>occursin</code></li></ul><h2 id="Performance"><a class="docs-heading-anchor" href="#Performance">Performance</a><a id="Performance-1"></a><a class="docs-heading-anchor-permalink" href="#Performance" title="Permalink"></a></h2><p>The code search performance bottleneck is parsing. The search itself is about 20x faster than parsing and similar in performance to an optimized regex library. Consequently, if you want high performance repeated code search, you should cache parsed SyntaxNodes and pass them directly to search functions.</p><h4 id="Benchmarks"><a class="docs-heading-anchor" href="#Benchmarks">Benchmarks</a><a id="Benchmarks-1"></a><a class="docs-heading-anchor-permalink" href="#Benchmarks" title="Permalink"></a></h4><p>Using the <a href="https://github.com/LilithHafner/CodeSearch.jl/blob/6820e642320f803407bcbc07e691277dc4d91ae4/src/CodeSearch.jl">395 lines of source code of this package as of 6820e64232</a> as a test case, on a 2022 M2 mac running <a href="https://asahilinux.org/">Asahi Linux</a>, we can see the following performance:</p><table><tr><th style="text-align: right">Operation</th><th style="text-align: right">Time</th><th style="text-align: right">Time per line</th><th style="text-align: right">Benchmark</th></tr><tr><td style="text-align: right">Searching a string</td><td style="text-align: right"><code>541.0 μs</code></td><td style="text-align: right"><code>1.37 μs</code></td><td style="text-align: right"><code>@b collect(eachmatch(j&quot;* !== nothing&quot;, node)) seconds=1</code></td></tr><tr><td style="text-align: right">Parsing a string</td><td style="text-align: right"><code>516.8 μs</code></td><td style="text-align: right"><code>1.31 μs</code></td><td style="text-align: right"><code>@b parseall(SyntaxNode, str, ignore_errors=true) seconds=1</code></td></tr><tr><td style="text-align: right">Searching a SyntaxNode</td><td style="text-align: right"><code>20.9 μs</code></td><td style="text-align: right"><code>53.0 ns</code></td><td style="text-align: right"><code>@b collect(eachmatch(j&quot;* !== nothing&quot;, node)) seconds=1</code></td></tr><tr><td style="text-align: right">Regex search</td><td style="text-align: right"><code>22.7 μs</code></td><td style="text-align: right"><code>57.5 ns</code></td><td style="text-align: right"><code>@b collect(eachmatch(r&quot;.* !== nothing&quot;, str)) seconds=1</code></td></tr></table><h4 id="Setup-for-benchmarks"><a class="docs-heading-anchor" href="#Setup-for-benchmarks">Setup for benchmarks</a><a id="Setup-for-benchmarks-1"></a><a class="docs-heading-anchor-permalink" href="#Setup-for-benchmarks" title="Permalink"></a></h4><pre><code class="language-julia hljs">shell&gt; git clone https://github.com/LilithHafner/CodeSearch.jl CodeSearch
[...]

shell&gt; cd CodeSearch

shell&gt; git checkout 6820e642320f803407bcbc07e691277dc4d91ae4
[...]

julia&gt; using CodeSearch, JuliaSyntax, Chairmarks

julia&gt; str = read(&quot;src/CodeSearch.jl&quot;, String);

julia&gt; node = parseall(SyntaxNode, str, ignore_errors=true);</code></pre><h2 id="Credits"><a class="docs-heading-anchor" href="#Credits">Credits</a><a id="Credits-1"></a><a class="docs-heading-anchor-permalink" href="#Credits" title="Permalink"></a></h2><p>Lilith Hafner is the original author of this package. CodeSearch.jl would not exist without Claire Foster&#39;s <a href="https://github.com/JuliaLang/JuliaSyntax.jl/">JuliaSyntax</a> which does all the parsing and provides appropriate data structures to represent parsed code.</p></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="internals/">Internals »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Friday 12 April 2024 16:05">Friday 12 April 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
